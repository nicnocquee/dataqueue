---
title: Initialize Queue
---

After defining your job types, payloads, and handlers, you need to initialize the job queue which basically sets up the connection pool to the Postgres database.

```typescript title="@lib/queue.ts"
import { initJobQueue } from '@nicnocquee/dataqueue';
import { type JobPayloadMap } from './types/job-payload-map';

let jobQueue: ReturnType<typeof initJobQueue<JobPayloadMap>> | null = null;

export const getJobQueue = () => {
  if (!jobQueue) {
    // [!code highlight:6]
    jobQueue = initJobQueue<JobPayloadMap>({
      databaseConfig: {
        connectionString: process.env.PG_DATAQUEUE_DATABASE, // Set this in your environment
      },
      verbose: process.env.NODE_ENV === 'development',
    });
  }
  return jobQueue;
};
```

You can now use this queue instance throughout your app to add jobs, process jobs, and more.

```typescript title="@/app/actions/send-email.ts"
import { getJobQueue } from '@/lib/queue';

const sendEmail = async () => {
  // [!code highlight:8]
  const jobQueue = getJobQueue();
  await jobQueue.addJob({
    jobType: 'send_email',
    payload: {
      to: 'test@example.com',
      subject: 'Hello',
      body: 'Hello, world!',
    },
  });
};
```

## SSL Configuration

Most managed Postgres providers (like DigitalOcean, Supabase, etc.) require you to use a CA certificate (`.crt` file) to verify the server's identity when connecting over SSL. You typically do **not** need a client certificate or keyâ€”just the CA `.crt` file provided by your provider. **However, if your provider or security policy requires client authentication, you can also provide a client certificate and key.**

You can configure SSL for your database connection in several ways, depending on your environment and security requirements.

### Using PEM Strings from Environment Variables

This is ideal for serverless environments where you cannot mount files. Store your CA certificate, and optionally client certificate and key, as environment variables. Use the standard Postgres environment variables: `PGSSLCERT` and `PGSSLKEY` for client authentication if needed. If the value does not start with `file://`, it will be used directly as a PEM string.

```typescript title="@lib/queue.ts"
import { initJobQueue } from '@nicnocquee/dataqueue';
import { type JobPayloadMap } from './types/job-payload-map';

let jobQueue: ReturnType<typeof initJobQueue<JobPayloadMap>> | null = null;

export const getJobQueue = () => {
  if (!jobQueue) {
    jobQueue = initJobQueue<JobPayloadMap>({
      databaseConfig: {
        connectionString: process.env.PG_DATAQUEUE_DATABASE, // Set this in your environment
        ssl: {
          ca: process.env.PGSSLROOTCERT, // PEM string: the content of your .crt file
          cert: process.env.PGSSLCERT, // PEM string (optional, for client authentication)
          key: process.env.PGSSLKEY, // PEM string (optional, for client authentication)
          rejectUnauthorized: true, // Always true for CA-signed certs
        },
      },
      verbose: process.env.NODE_ENV === 'development',
    });
  }
  return jobQueue;
};
```

### Using File Paths

If you have the CA certificate, client certificate, or key on disk, provide their absolute paths using the `file://` prefix. Only values starting with `file://` will be loaded from the file system; all others are treated as PEM strings. You can also set the environment variables `PGSSLROOTCERT`, `PGSSLCERT`, and `PGSSLKEY` to `file://` paths.

```typescript title="@lib/queue.ts"
import { initJobQueue } from '@nicnocquee/dataqueue';
import { type JobPayloadMap } from './types/job-payload-map';

let jobQueue: ReturnType<typeof initJobQueue<JobPayloadMap>> | null = null;

export const getJobQueue = () => {
  if (!jobQueue) {
    jobQueue = initJobQueue<JobPayloadMap>({
      databaseConfig: {
        connectionString: process.env.PG_DATAQUEUE_DATABASE,
        ssl: {
          ca: 'file:///absolute/path/to/ca.crt', // Path to your provider's CA cert
          cert: 'file:///absolute/path/to/client.crt', // optional, for client authentication
          key: 'file:///absolute/path/to/client.key', // optional, for client authentication
          rejectUnauthorized: true,
        },
      },
      verbose: process.env.NODE_ENV === 'development',
    });
  }
  return jobQueue;
};
```

### Using Self-Signed Certificates

If you are using a self-signed certificate and want to skip certificate validation (not recommended for production), set `rejectUnauthorized` to `false`. You can use either a PEM string or a `file://` path for `ca`, `cert`, and `key` as described above, or set the corresponding environment variables.

```typescript title="@lib/queue.ts"
import { initJobQueue } from '@nicnocquee/dataqueue';
import { type JobPayloadMap } from './types/job-payload-map';

let jobQueue: ReturnType<typeof initJobQueue<JobPayloadMap>> | null = null;

export const getJobQueue = () => {
  if (!jobQueue) {
    jobQueue = initJobQueue<JobPayloadMap>({
      databaseConfig: {
        connectionString: process.env.PG_DATAQUEUE_DATABASE,
        ssl: {
          ca: process.env.PGSSLROOTCERT, // PEM string or 'file://' path
          cert: process.env.PGSSLCERT, // optional, PEM string or 'file://' path
          key: process.env.PGSSLKEY, // optional, PEM string or 'file://' path
          rejectUnauthorized: false, // Accept self-signed certs (dev only)
        },
      },
      verbose: process.env.NODE_ENV === 'development',
    });
  }
  return jobQueue;
};
```

<Callout type="warn">
  <strong>Note:</strong>
  <ul>
    <li>
      When using a custom CA, you must remove the <code>sslmode</code> parameter
      from the connection string. Otherwise, the connection may fail.
    </li>
    <li>
      If your provider or security policy requires client authentication, you
      can also provide <code>PGSSLCERT</code> and <code>PGSSLKEY</code> as PEM
      strings or <code>file://</code> paths.
    </li>
    <li>
      Only values starting with <code>file://</code> are loaded from the file
      system. All other values are treated as PEM strings.
    </li>
    <li>
      For production, always use <code>rejectUnauthorized: true</code> and a
      valid CA-signed certificate.
    </li>
    <li>
      For local development, <code>file://</code> paths are convenient.
    </li>
    <li>For serverless/cloud, use PEM strings via environment variables.</li>
    <li>
      These are the standard Postgres environment variables for SSL and are
      supported by both the CLI and the library.
    </li>
  </ul>
</Callout>
